<!doctype html>
<meta charset="utf-8" />
<title>canvas Frame-by-Frame Encoder (WebCodecs + Worker)</title>
<style>
  body { font: 14px/1.6 system-ui; margin: 24px; color:white; background-color: #222; }
  fieldset { border:1px solid #ddd; padding:12px; margin-bottom:12px; }
  label { margin-right: 12px; display:inline-flex; align-items:center; gap:6px; }
  input[type=number] { width: 6em; }
  button { padding: 8px 14px; margin-right: 8px; }
  #row { display:flex; gap:24px; align-items:flex-start; }
  #preview { border:1px solid #ddd; background:#000; }
  #log { white-space: pre-wrap; border: 1px solid #eee; padding: 8px; height: 200px; overflow:auto; }
  a#dl { display:none; }
</style>

<h1>CANVAS offscreen renderer</h1>

<fieldset>
  <legend>render settings</legend>
  <label>Width <input id="w" type="number" value="1280" step="1" min="16"></label>
  <label>Height <input id="h" type="number" value="720" step="1" min="16"></label>
  <label>Start time(sec) <input id="startSec" type="number" value="0" step="0.1" min="0"></label>
  <label>End time(sec) <input id="endSec" type="number" value="5" step="0.1" min="0"></label>
  <label>FPS <input id="fps" type="number" value="30" step="1" min="1"></label>
  <label>Keyframe every(s) <input id="gopSec" type="number" value="2" step="0.5" min="0.5"></label>
  <label>Bitrate(Mbps) <input id="mbps" type="number" value="10" step="0.5" min="1"></label>
</fieldset>

<fieldset>
  <legend>scene module</legend>
  <label>Module URL <input id="sceneModule" type="text" value="" style="min-width:260px;"></label>
  <button id="btnReloadScene">import</button>
</fieldset>

<fieldset>
  <legend>preview</legend>
  <div id="row">
    <!-- Workerへ譲渡する実キャンバス（直接表示しない） -->
    <canvas id="hiddenCanvas" width="1280" height="720" style="display:none"></canvas>
    <!-- プレビュー表示用（メインスレッドで描くだけの2D） -->
    <div>
      <canvas id="preview" width="640" height="360"></canvas>
      <div style="margin-top:8px;display:flex;flex-direction:column;gap:8px;">
        <label style="display:flex;align-items:center;gap:10px;">
          <span>time</span>
          <input id="pvSec" type="range" value="0" min="0" max="5" step="0.033" style="flex:1 1 auto;">
          <span><span id="pvSecLabel">0.00</span> sec</span>
        </label>
        <button id="btnPreview">render one frame</button>
      </div>
    </div>
  </div>
</fieldset>

<fieldset>
  <legend>export</legend>
  <button id="btnRender">start render（WebM outout）</button>
  <button id="btnCancelRender" disabled>cancel render</button>
  <a id="dl" download="render.webm">Download render.webm</a>
  <div id="renderStats" style="margin-top:8px;display:flex;flex-direction:row;gap:4px;">
    <span>elapsed: <strong id="renderElapsed">0.00</strong> sec</span>
    <span>frame/sec: <strong id="renderFps">0.00</strong></span>
  </div>
</fieldset>

<div id="log"></div>

<script type="module">
  // ========== UI要素 ==========
  const wEl = document.getElementById('w');
  const hEl = document.getElementById('h');
  const startEl = document.getElementById('startSec');
  const endEl = document.getElementById('endSec');
  const fpsEl = document.getElementById('fps');
  const gopSecEl = document.getElementById('gopSec');
  const mbpsEl = document.getElementById('mbps');

  const hiddenCanvas = document.getElementById('hiddenCanvas'); // Offscreen化してWorkerへ
  const previewCanvas = document.getElementById('preview');     // 表示専用
  const previewCtx = previewCanvas.getContext('2d');

  const pvSecEl = document.getElementById('pvSec');
  const pvSecLabelEl = document.getElementById('pvSecLabel');
  const btnPreview = document.getElementById('btnPreview');

  const btnRender = document.getElementById('btnRender');
  const btnCancelRender = document.getElementById('btnCancelRender');
  const dl = document.getElementById('dl');
  const logEl = document.getElementById('log');
  const sceneModuleEl = document.getElementById('sceneModule');
  const btnReloadScene = document.getElementById('btnReloadScene');
  const renderElapsedEl = document.getElementById('renderElapsed');
  const renderFpsEl = document.getElementById('renderFps');
  let renderInFlight = false;
  let workerReady = false;
  let renderStartTime = 0;
  let renderLastFrameCount = 0;
  function log(...args){
 //   console.log(...args);
    logEl.textContent += args.join(' ') + '\n';
    logEl.scrollTop = logEl.scrollHeight;
  }

  function resetRenderStats(){
    renderStartTime = 0;
    renderLastFrameCount = 0;
    if (renderElapsedEl) {
      renderElapsedEl.textContent = '0.00';
    }
    if (renderFpsEl) {
      renderFpsEl.textContent = '0.00';
    }
  }

  function updateRenderStats(doneFrames){
    if (!renderElapsedEl || !renderFpsEl) {
      return;
    }
    if (renderStartTime <= 0) {
      renderStartTime = performance.now();
    }
    const elapsedSec = Math.max(0, (performance.now() - renderStartTime) / 1000);
    const fps = elapsedSec > 0 ? doneFrames / elapsedSec : 0;
    renderElapsedEl.textContent = elapsedSec.toFixed(2);
    renderFpsEl.textContent = fps.toFixed(2);
    renderLastFrameCount = doneFrames;
  }

  function finalizeRenderStats(){
    if (!renderElapsedEl || !renderFpsEl || renderStartTime <= 0) {
      return;
    }
    const elapsedSec = Math.max(0, (performance.now() - renderStartTime) / 1000);
    renderElapsedEl.textContent = elapsedSec.toFixed(2);
    const fps = elapsedSec > 0 ? renderLastFrameCount / elapsedSec : 0;
    renderFpsEl.textContent = fps.toFixed(2);
  }

  resetRenderStats();

  function getSceneModuleValue(){
    const raw = sceneModuleEl?.value ?? '';
    const trimmed = raw.trim();
    return trimmed || location.search.substring(1) || './scene-default.js';
  }

  function deriveExportFilename(modulePath){
    if (typeof modulePath !== 'string' || !modulePath.trim()) {
      return 'render.webm';
    }
    let target = modulePath.trim();
    try {
      const url = new URL(target, window.location.href);
      target = url.pathname || target;
    } catch (_) {
      // Skip URL normalization when modulePath is relative
    }
    target = target.split(/[?#]/)[0];
    const segments = target.split('/').filter(Boolean);
    const last = segments.pop() || target;
    const base = last.replace(/\.[^.]+$/, '') || 'render';
    const safeBase = base.replace(/[^\w.-]+/g, '_') || 'render';
    return `${safeBase}.webm`;
  }

  // ========== Worker起動 ==========
  const off = hiddenCanvas.transferControlToOffscreen();  // three.js はこのOffscreenCanvasに描く
  const workerUrl = './worker.js?' +  String(Date.now());
  console.log('[main] new Worker', workerUrl);
  let worker;
  try {
    worker = new Worker(workerUrl, { type: 'module' });
  } catch (err) {
    console.error('[main] new Worker threw', err);
    log('[main] new Worker threw', err.message || err);
    throw err;
  }

  // 初期化メッセージ：とりあえずデフォルト解像度で立ち上げ
  const initialSceneModule = getSceneModuleValue();
  let currentSceneModule = initialSceneModule;
  if (sceneModuleEl) {
    sceneModuleEl.value = initialSceneModule;
  }
  worker.postMessage({ type:'init', sceneModule: initialSceneModule, canvas: off }, [off]);

  // 受信ハンドラ（プレビュー画像・進捗・完了）
  const chunks = []; // muxer側から最終的にBlob一発で来る設計だが保険で残す
  worker.onmessage = (ev) => {
    if (0 && ev.data?.type !== 'preview') {
      console.log('[main] worker message', ev.data);
    }
    const { type } = ev.data;
    if (type === 'preview') {
      // 1フレームプレビュー：ImageBitmapを受け取り2Dに描画
      const bmp = ev.data.bitmap;
      drawPreview(bmp, {
        t: ev.data.timeSec,
        w: ev.data.width,
        h: ev.data.height,
        origin: ev.data.origin || 'ui'
      });
      bmp.close();
    } else if (type === 'progress') {
      log(`Frame ${ev.data.done}/${ev.data.total}`);
      updateRenderStats(ev.data.done);
    } else if (type === 'done') {
      // 完成Blob URLを受け取る
      const { url, sizeBytes } = ev.data;
      const exportName = deriveExportFilename(currentSceneModule || getSceneModuleValue());
      dl.href = url;
      dl.download = exportName;
      dl.textContent = `Download ${exportName}`;
      dl.style.display = 'inline-block';
      log(`Done. ${Math.round(sizeBytes/1024/1024*10)/10} MB`);
      btnRender.disabled = false;
      btnCancelRender.disabled = true;
      renderInFlight = false;
      finalizeRenderStats();
      renderStartTime = 0;
    } else if (type === 'cancelled') {
      log('Render cancelled.');
      btnRender.disabled = false;
      btnCancelRender.disabled = true;
      renderInFlight = false;
      finalizeRenderStats();
      renderStartTime = 0;
    } else if (type === 'ready') {
      workerReady = true;
      log('[main] worker ready');
      handleWorkerReady(ev.data);
    } else if (type === 'log') {
      log(ev.data.message);
    } else if (type === 'error') {
      log('ERROR:', ev.data.message);
      //ERROR: OperationError: A valid external Instance reference no longer exists. CONTEXT LOST
      btnRender.disabled = false;
      btnCancelRender.disabled = true;
      renderInFlight = false;
      finalizeRenderStats();
      renderStartTime = 0;
    }
  };
  worker.addEventListener('error', (ev) => {
    console.error('[main] worker error', ev);
    log('[main] worker error', ev instanceof ErrorEvent
      ? `ErrorEvent message=${ev.message} file=${ev.filename}:${ev.lineno}:${ev.colno}`
      : `Event props: ${Object.getOwnPropertyNames(ev).map((k) => `${k}=${ev[k]}`).join(', ')}`);
    finalizeRenderStats();
    renderStartTime = 0;
  });
  worker.addEventListener('messageerror', (ev) => {
    console.error('[main] worker messageerror', ev);
    log('[main] worker messageerror');
    finalizeRenderStats();
    renderStartTime = 0;
  });

  // ========== プレビュー描画（HUD文字オーバレイ） ==========
  function drawPreview(bmp, meta){
    // アスペクトフィット（letterbox）
    const dstW = previewCanvas.width, dstH = previewCanvas.height;
    const srcW = bmp.width, srcH = bmp.height;
    const s = Math.min(dstW/srcW, dstH/srcH);
    const w = Math.round(srcW*s), h = Math.round(srcH*s);
    const x = Math.floor((dstW - w)/2), y = Math.floor((dstH - h)/2);

    previewCtx.save();
    previewCtx.clearRect(0,0,dstW,dstH);
    previewCtx.globalCompositeOperation = 'copy';
    previewCtx.drawImage(bmp, x, y, w, h);
    previewCtx.globalCompositeOperation = 'source-over';

    // HUD：時刻と解像度
    previewCtx.font = '12px ui-monospace, SFMono-Regular, Menlo, monospace';
    previewCtx.textBaseline = 'bottom';
    previewCtx.fillStyle = 'rgba(0,0,0,.6)';
    previewCtx.fillRect(6, dstH-24, 240, 18);
    previewCtx.fillStyle = '#fff';
    previewCtx.fillText(`t=${meta.t.toFixed(3)}s  (${meta.w}x${meta.h})`, 10, dstH-10);
    previewCtx.restore();

    if (0 && meta.origin !== 'render') {
      try {
        const center = previewCtx.getImageData(Math.floor(dstW/2), Math.floor(dstH/2), 1, 1).data;
        console.log('[main] preview center pixel', Array.from(center));
        log(`[main] preview center pixel ${Array.from(center).join(',')}`);
      } catch (err) {
        console.error('[main] getImageData failed', err);
      }
    }
  }

  // ========== UIイベント ==========
  const PREVIEW_DEBOUNCE_MS = 120;
  let previewDebounceHandle = 0;

  function formatNumber(value){
    const num = Number(value);
    if (!Number.isFinite(num)) {
      return '0';
    }
    return String(num);
  }

  function clampRenderRange(){
    const fps = Math.max(1, +fpsEl.value);
    let start = Math.max(0, Number(startEl.value));
    if (!Number.isFinite(start)) {
      start = 0;
    }
    let end = Number(endEl.value);
    if (!Number.isFinite(end)) {
      end = start;
    }
    if (end < start) {
      end = start;
    }
    const minDuration = 1 / fps;
    if ((end - start) < minDuration) {
      end = start + minDuration;
    }
    startEl.value = formatNumber(start);
    endEl.value = formatNumber(end);
    return { start, end, fps };
  }

  function updatePreviewLabel(value){
    if (!pvSecLabelEl) return;
    let t = Number(value);
    if (!Number.isFinite(t)) {
      t = Number(pvSecEl.value);
    }
    if (!Number.isFinite(t)) {
      t = 0;
    }
    pvSecLabelEl.textContent = t.toFixed(2);
  }

  function ensurePreviewWithinBounds(){
    const { start, end, fps } = clampRenderRange();
    pvSecEl.min = String(start);
    pvSecEl.max = String(end);
    pvSecEl.step = String(Math.max(0.001, 1 / fps));
    let clamped = Number(pvSecEl.value);
    if (!Number.isFinite(clamped)) {
      clamped = start;
    }
    if (clamped < start) {
      clamped = start;
    } else if (clamped > end) {
      clamped = end;
    }
    if (Number.isNaN(clamped)) {
      pvSecEl.value = String(start);
    } else if (clamped !== +pvSecEl.value) {
      pvSecEl.value = String(clamped);
    }
    updatePreviewLabel(clamped);
    return clamped;
  }

  function queuePreview(immediate = false){
    if (previewDebounceHandle) {
      clearTimeout(previewDebounceHandle);
      previewDebounceHandle = 0;
    }
    if (immediate) {
      sendPreviewRequest();
    } else {
      previewDebounceHandle = setTimeout(() => {
        previewDebounceHandle = 0;
        sendPreviewRequest();
      }, PREVIEW_DEBOUNCE_MS);
    }
  }

  function sendPreviewRequest(){
    const width = +wEl.value|0, height = +hEl.value|0;
    const fps = Math.max(1, +fpsEl.value);
    const { start, end } = clampRenderRange();
    const current = Math.min(end, Math.max(start, +pvSecEl.value || start));
    pvSecEl.value = String(current);
    updatePreviewLabel(current);

    worker.postMessage({ type:'resize', width, height });
    worker.postMessage({ type:'preview', timeSec: current, fps });
  }

  pvSecEl.addEventListener('input', () => {
    ensurePreviewWithinBounds();
    queuePreview(true);
  });

  startEl.addEventListener('change', () => {
    const before = +pvSecEl.value || 0;
    const after = ensurePreviewWithinBounds();
    if (after !== before) {
      queuePreview(true);
    }
  });
  endEl.addEventListener('change', () => {
    const before = +pvSecEl.value || 0;
    const after = ensurePreviewWithinBounds();
    if (after !== before) {
      queuePreview(true);
    }
  });
  fpsEl.addEventListener('input', () => {
    ensurePreviewWithinBounds();
    queuePreview(true);
  });

  // 1フレームだけプレビュー
  btnPreview.onclick = () => {
    ensurePreviewWithinBounds();
    queuePreview(true);
  };

  if (btnReloadScene) {
    btnReloadScene.addEventListener('click', () => {
      if (!worker) {
        log('[main] worker not ready');
        return;
      }
      const previewTime = ensurePreviewWithinBounds();
      const modulePath = getSceneModuleValue();
      log(`[main] reload scene module => ${modulePath}`);
      currentSceneModule = modulePath;
      worker.postMessage({ type:'loadScene', module: modulePath, timeSec: previewTime });
    });
  }

  if (sceneModuleEl) {
    sceneModuleEl.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter') {
        ev.preventDefault();
        btnReloadScene?.click();
      }
    });
  }

  // 初期化：スライダー範囲とラベル
  ensurePreviewWithinBounds();

  // フルレンダリング開始
  btnRender.onclick = () => {
    if (renderInFlight) {
      log('[main] render already running');
      return;
    }
    btnRender.disabled = true;
    btnCancelRender.disabled = false;
    renderInFlight = true;
    dl.style.display = 'none';
    previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
    chunks.length = 0;
    logEl.textContent = '';

    const width = +wEl.value|0, height = +hEl.value|0;
    const { start, end, fps } = clampRenderRange();
    const duration = Math.max(0, end - start);
    const total = Math.max(1, Math.round(duration * fps));
    const gopSec = Math.max(0.5, +gopSecEl.value);
    const mbps = Math.max(1, +mbpsEl.value);
    currentSceneModule = getSceneModuleValue();
    renderStartTime = performance.now();
    renderLastFrameCount = 0;
    if (renderElapsedEl) {
      renderElapsedEl.textContent = '0.00';
    }
    if (renderFpsEl) {
      renderFpsEl.textContent = '0.00';
    }

    worker.postMessage({ type:'resize', width, height });

    // WebCodecs + WebM muxerでオフライン1フレームずつエンコード
    worker.postMessage({
      type:'render',
      totalFrames: total,
      fps,
      bitrate: Math.round(mbps * 1_000_000),  // Mbps → bps
      keyframeIntervalSec: gopSec,
      startSec: start,
      endSec: end
    });
  };

  btnCancelRender.onclick = () => {
    if (!worker) {
      log('[main] worker not ready');
      return;
    }
    if (!renderInFlight) {
      log('[main] no active render to cancel');
      return;
    }
    btnCancelRender.disabled = true;
    worker.postMessage({ type:'cancelRender' });
    log('[main] cancel requested');
  };

  function handleWorkerReady(payload = {}) {
    if (!workerReady || !worker) {
      return;
    }
    const modulePath = payload.sceneModule || getSceneModuleValue();
    currentSceneModule = modulePath;
    const previewTime = ensurePreviewWithinBounds();
    log(`[main] initial scene load => ${modulePath} @ t=${previewTime.toFixed(3)}`);
    worker.postMessage({ type:'loadScene', module: modulePath, timeSec: previewTime });
  }
</script>
